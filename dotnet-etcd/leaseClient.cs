// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using dotnet_etcd.interfaces;
using Etcdserverpb;
using Grpc.Core;

namespace dotnet_etcd;

public partial class EtcdClient
{
    /// <summary>
    ///     LeaseGrant creates a lease which expires if the server does not receive a keepAlive
    ///     within a given time to live period. All keys attached to the lease will be expired and
    ///     deleted if the lease expires. Each expired key generates a delete event in the event history.
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
    /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
    /// <param name="cancellationToken">An optional token for canceling the call.</param>
    /// <returns>The response received from the server.</returns>
    public LeaseGrantResponse LeaseGrant(LeaseGrantRequest request, Metadata headers = null,
        DateTime? deadline = null,
        CancellationToken cancellationToken = default) => CallEtcd(connection => connection.LeaseClient
        .LeaseGrant(request, headers, deadline, cancellationToken));

    /// <summary>
    ///     LeaseGrant creates a lease in async which expires if the server does not receive a keepAlive
    ///     within a given time to live period. All keys attached to the lease will be expired and
    ///     deleted if the lease expires. Each expired key generates a delete event in the event history.
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
    /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
    /// <param name="cancellationToken">An optional token for canceling the call.</param>
    /// <returns>The response received from the server.</returns>
    public async Task<LeaseGrantResponse> LeaseGrantAsync(LeaseGrantRequest request,
        Metadata headers = null, DateTime? deadline = null,
        CancellationToken cancellationToken = default) => await CallEtcdAsync(async connection => await connection
        .LeaseClient
        .LeaseGrantAsync(request, headers, deadline, cancellationToken)).ConfigureAwait(false);

    /// <summary>
    ///     LeaseRevoke revokes a lease. All keys attached to the lease will expire and be deleted.
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
    /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
    /// <param name="cancellationToken">An optional token for canceling the call.</param>
    /// <returns>The response received from the server.</returns>
    public LeaseRevokeResponse LeaseRevoke(LeaseRevokeRequest request, Metadata headers = null,
        DateTime? deadline = null,
        CancellationToken cancellationToken = default) => CallEtcd(connection => connection.LeaseClient
        .LeaseRevoke(request, headers, deadline, cancellationToken));

    /// <summary>
    ///     LeaseRevoke revokes a lease in async. All keys attached to the lease will expire and be deleted.
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
    /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
    /// <param name="cancellationToken">An optional token for canceling the call.</param>
    /// <returns>The response received from the server.</returns>
    public async Task<LeaseRevokeResponse> LeaseRevokeAsync(LeaseRevokeRequest request,
        Metadata headers = null, DateTime? deadline = null,
        CancellationToken cancellationToken = default) => await CallEtcdAsync(async connection => await connection
        .LeaseClient
        .LeaseRevokeAsync(request, headers, deadline, cancellationToken)).ConfigureAwait(false);

    /// <summary>
    ///     LeaseKeepAlive keeps the lease alive by streaming keep alive requests from the client
    ///     to the server and streaming keep alive responses from the server to the client.
    /// </summary>
    /// <param name="cancellationTokenSource">
    ///     Cancellation token source that reflects communication status between server and
    ///     client.
    /// </param>
    /// <param name="leaseId">Granted lease identifier. <see cref="LeaseGrant" /> and <see cref="LeaseGrantAsync" /></param>
    /// <param name="keepAliveTimeout">Time to the next communication with Etcd server in milliseconds.</param>
    /// <param name="communicationTimeout">Time to wait response from Etcd server in milliseconds.</param>
    /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
    /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
    public Task LeaseKeepAlive(CancellationTokenSource cancellationTokenSource, long leaseId,
        int keepAliveTimeout = 1000, int? communicationTimeout = null, Metadata headers = null,
        DateTime? deadline = null) => CallEtcdAsync(connection =>
    {
        ArgumentNullException.ThrowIfNull(cancellationTokenSource);
#pragma warning disable CA1512 // ArgumentOutOfRangeException.ThrowIfNegativeOrZero it is only .NET 8 now
        if (keepAliveTimeout <= 0)
        {
            throw new ArgumentOutOfRangeException(nameof(keepAliveTimeout));
        }
#pragma warning restore CA1512
        if (communicationTimeout != null && communicationTimeout <= 0)
        {
            throw new ArgumentOutOfRangeException(nameof(communicationTimeout));
        }

        CancellationToken cancellationToken = cancellationTokenSource.Token;
        int communicationTimeoutInMilliseconds = communicationTimeout ?? keepAliveTimeout / 2;

        async ValueTask WriteAsync(AsyncDuplexStreamingCall<LeaseKeepAliveRequest, LeaseKeepAliveResponse> leaser,
            LeaseKeepAliveRequest request, int timeoutInMilliseconds, CancellationToken cancellationToken)
        {
            // communication timeout
            using CancellationTokenSource cancellationTokenSource =
                CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cancellationTokenSource.CancelAfter(timeoutInMilliseconds);

            await leaser.RequestStream.WriteAsync(request, cancellationTokenSource.Token)
                .ConfigureAwait(false);
        }

        async ValueTask<bool> MoveNextAsync(
            AsyncDuplexStreamingCall<LeaseKeepAliveRequest, LeaseKeepAliveResponse> leaser, int timeoutInMilliseconds,
            CancellationToken cancellationToken)
        {
            // communication timeout
            using CancellationTokenSource cancellationTokenSource =
                CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cancellationTokenSource.CancelAfter(timeoutInMilliseconds);

            return await leaser.ResponseStream.MoveNext(cancellationTokenSource.Token)
                .ConfigureAwait(false);
        }

        AsyncDuplexStreamingCall<LeaseKeepAliveRequest, LeaseKeepAliveResponse> LeaseKeepAlive(IConnection connection,
            int timeoutInMilliseconds, CancellationToken cancellationToken)
        {
            // communication timeout
            using CancellationTokenSource cancellationTokenSource =
                CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cancellationTokenSource.CancelAfter(timeoutInMilliseconds);

            return connection.LeaseClient.LeaseKeepAlive(headers, deadline, cancellationTokenSource.Token);
        }

        async Task KeepAliveAsync()
        {
            LeaseKeepAliveRequest request = new() { ID = leaseId };

            try
            {
                using AsyncDuplexStreamingCall<LeaseKeepAliveRequest, LeaseKeepAliveResponse> leaser =
                    LeaseKeepAlive(connection, communicationTimeoutInMilliseconds, cancellationToken);

                while (!cancellationToken.IsCancellationRequested)
                {
                    await WriteAsync(leaser, request, communicationTimeoutInMilliseconds, cancellationToken)
                        .ConfigureAwait(false);

                    if (!await MoveNextAsync(leaser, communicationTimeoutInMilliseconds, cancellationToken)
                            .ConfigureAwait(false))
                    {
                        try
                        {
                            if (!cancellationTokenSource.IsCancellationRequested)
                            {
#if NET8_0_OR_GREATER
                                await cancellationTokenSource.CancelAsync()
                                    .ConfigureAwait(false);
#else
                                    cancellationTokenSource.Cancel();
#endif
                            }
                        }
                        finally
                        {
                            await leaser.RequestStream.CompleteAsync()
                                .ConfigureAwait(false);
                        }

                        break;
                    }

                    LeaseKeepAliveResponse update = leaser.ResponseStream.Current;
                    if (update.ID != leaseId || update.TTL == 0) // expired
                    {
                        try
                        {
                            if (!cancellationTokenSource.IsCancellationRequested)
                            {
#if NET8_0_OR_GREATER
                                await cancellationTokenSource.CancelAsync()
                                    .ConfigureAwait(false);
#else
                                    cancellationTokenSource.Cancel();
#endif
                            }
                        }
                        finally
                        {
                            await leaser.RequestStream.CompleteAsync()
                                .ConfigureAwait(false);
                        }

                        break;
                    }

                    await Task.Delay(keepAliveTimeout, cancellationToken)
                        .ConfigureAwait(false);
                }
            }
            finally
            {
                if (!cancellationTokenSource.IsCancellationRequested)
                {
#if NET8_0_OR_GREATER
                    await cancellationTokenSource.CancelAsync()
                        .ConfigureAwait(false);
#else
                        cancellationTokenSource.Cancel();
#endif
                }
            }
        }

        return Task.Run(KeepAliveAsync, cancellationToken);
    });

    /// <summary>
    ///     LeaseKeepAlive keeps the lease alive by streaming keep alive requests from the client
    ///     to the server and streaming keep alive responses from the server to the client.
    /// </summary>
    /// <param name="leaseId"></param>
    /// <param name="cancellationToken"></param>
    public async Task LeaseKeepAlive(long leaseId, CancellationToken cancellationToken) => await CallEtcdAsync(
        async connection =>
        {
            using (AsyncDuplexStreamingCall<LeaseKeepAliveRequest, LeaseKeepAliveResponse> leaser =
                   connection.LeaseClient.LeaseKeepAlive(cancellationToken: cancellationToken))
            {
                LeaseKeepAliveRequest request = new() { ID = leaseId };

                while (true)
                {
                    cancellationToken.ThrowIfCancellationRequested();

                    await leaser.RequestStream.WriteAsync(request).ConfigureAwait(false);
                    if (!await leaser.ResponseStream.MoveNext(cancellationToken).ConfigureAwait(false))
                    {
                        await leaser.RequestStream.CompleteAsync().ConfigureAwait(false);
                        throw new EndOfStreamException();
                    }

                    LeaseKeepAliveResponse update = leaser.ResponseStream.Current;
                    if (update.ID != leaseId || update.TTL == 0) // expired
                    {
                        await leaser.RequestStream.CompleteAsync().ConfigureAwait(false);
                        return;
                    }

                    await Task.Delay(TimeSpan.FromMilliseconds(update.TTL * 1000 / 3), cancellationToken)
                        .ConfigureAwait(false);
                }
            }
        }).ConfigureAwait(false);

    /// <summary>
    ///     LeaseKeepAlive keeps the lease alive by streaming keep alive requests from the client
    ///     to the server and streaming keep alive responses from the server to the client.
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="method"></param>
    /// <param name="cancellationToken"></param>
    /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
    public async Task LeaseKeepAlive(LeaseKeepAliveRequest request, Action<LeaseKeepAliveResponse> method,
        CancellationToken cancellationToken, Metadata headers = null) => await CallEtcdAsync(async connection =>
    {
        using (AsyncDuplexStreamingCall<LeaseKeepAliveRequest, LeaseKeepAliveResponse> leaser =
               connection.LeaseClient
                   .LeaseKeepAlive(headers, cancellationToken: cancellationToken))
        {
            Task leaserTask = Task.Run(async () =>
            {
                while (await leaser.ResponseStream.MoveNext(cancellationToken).ConfigureAwait(false))
                {
                    LeaseKeepAliveResponse update = leaser.ResponseStream.Current;
                    method(update);
                }
            }, cancellationToken);

            await leaser.RequestStream.WriteAsync(request).ConfigureAwait(false);
            await leaser.RequestStream.CompleteAsync().ConfigureAwait(false);
            await leaserTask.ConfigureAwait(false);
        }
    }).ConfigureAwait(false);

    /// <summary>
    ///     LeaseKeepAlive keeps the lease alive by streaming keep alive requests from the client
    ///     to the server and streaming keep alive responses from the server to the client.
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="methods"></param>
    /// <param name="cancellationToken"></param>
    /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
    public async Task LeaseKeepAlive(LeaseKeepAliveRequest request, Action<LeaseKeepAliveResponse>[] methods,
        CancellationToken cancellationToken, Metadata headers = null) => await CallEtcdAsync(async connection =>
    {
        using (AsyncDuplexStreamingCall<LeaseKeepAliveRequest, LeaseKeepAliveResponse> leaser =
               connection.LeaseClient
                   .LeaseKeepAlive(headers, cancellationToken: cancellationToken))
        {
            Task leaserTask = Task.Run(async () =>
            {
                while (await leaser.ResponseStream.MoveNext(cancellationToken).ConfigureAwait(false))
                {
                    LeaseKeepAliveResponse update = leaser.ResponseStream.Current;
                    foreach (Action<LeaseKeepAliveResponse> method in methods)
                    {
                        method(update);
                    }
                }
            }, cancellationToken);

            await leaser.RequestStream.WriteAsync(request).ConfigureAwait(false);
            await leaser.RequestStream.CompleteAsync().ConfigureAwait(false);
            await leaserTask.ConfigureAwait(false);
        }
    }).ConfigureAwait(false);


    /// <summary>
    ///     LeaseKeepAlive keeps the lease alive by streaming keep alive requests from the client
    ///     to the server and streaming keep alive responses from the server to the client.
    /// </summary>
    /// <param name="requests"></param>
    /// <param name="method"></param>
    /// <param name="cancellationToken"></param>
    /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
    public async Task LeaseKeepAlive(LeaseKeepAliveRequest[] requests, Action<LeaseKeepAliveResponse> method,
        CancellationToken cancellationToken, Metadata headers = null) => await CallEtcdAsync(async connection =>
    {
        using (AsyncDuplexStreamingCall<LeaseKeepAliveRequest, LeaseKeepAliveResponse> leaser =
               connection.LeaseClient
                   .LeaseKeepAlive(headers, cancellationToken: cancellationToken))
        {
            Task leaserTask = Task.Run(async () =>
            {
                while (await leaser.ResponseStream.MoveNext(cancellationToken).ConfigureAwait(false))
                {
                    LeaseKeepAliveResponse update = leaser.ResponseStream.Current;
                    method(update);
                }
            }, cancellationToken);

            foreach (LeaseKeepAliveRequest request in requests)
            {
                await leaser.RequestStream.WriteAsync(request).ConfigureAwait(false);
            }

            await leaser.RequestStream.CompleteAsync().ConfigureAwait(false);
            await leaserTask.ConfigureAwait(false);
        }
    }).ConfigureAwait(false);

    /// <summary>
    ///     LeaseKeepAlive keeps the lease alive by streaming keep alive requests from the client
    ///     to the server and streaming keep alive responses from the server to the client.
    /// </summary>
    /// <param name="requests"></param>
    /// <param name="methods"></param>
    /// <param name="cancellationToken"></param>
    /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
    /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
    public async Task LeaseKeepAlive(LeaseKeepAliveRequest[] requests, Action<LeaseKeepAliveResponse>[] methods,
        CancellationToken cancellationToken, Metadata headers = null, DateTime? deadline = null) => await CallEtcdAsync(
        async connection =>
        {
            using (AsyncDuplexStreamingCall<LeaseKeepAliveRequest, LeaseKeepAliveResponse> leaser =
                   connection.LeaseClient
                       .LeaseKeepAlive(headers, deadline, cancellationToken))
            {
                Task leaserTask = Task.Run(async () =>
                {
                    while (await leaser.ResponseStream.MoveNext(cancellationToken).ConfigureAwait(false))
                    {
                        LeaseKeepAliveResponse update = leaser.ResponseStream.Current;
                        foreach (Action<LeaseKeepAliveResponse> method in methods)
                        {
                            method(update);
                        }
                    }
                }, cancellationToken);

                foreach (LeaseKeepAliveRequest request in requests)
                {
                    await leaser.RequestStream.WriteAsync(request).ConfigureAwait(false);
                }

                await leaser.RequestStream.CompleteAsync().ConfigureAwait(false);
                await leaserTask.ConfigureAwait(false);
            }
        }).ConfigureAwait(false);

    /// <summary>
    ///     LeaseTimeToLive retrieves lease information.
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
    /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
    /// <param name="cancellationToken">An optional token for canceling the call.</param>
    /// <returns>The response received from the server.</returns>
    public LeaseTimeToLiveResponse LeaseTimeToLive(LeaseTimeToLiveRequest request,
        Metadata headers = null, DateTime? deadline = null,
        CancellationToken cancellationToken = default) => CallEtcd(connection => connection.LeaseClient
        .LeaseTimeToLive(request, headers, deadline, cancellationToken));

    /// <summary>
    ///     LeaseTimeToLive retrieves lease information.
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
    /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
    /// <param name="cancellationToken">An optional token for canceling the call.</param>
    /// <returns>The call object.</returns>
    public async Task<LeaseTimeToLiveResponse> LeaseTimeToLiveAsync(LeaseTimeToLiveRequest request,
        Metadata headers = null, DateTime? deadline = null,
        CancellationToken cancellationToken = default) => await CallEtcdAsync(async connection => await connection
        .LeaseClient
        .LeaseTimeToLiveAsync(request, headers, deadline, cancellationToken)).ConfigureAwait(false);
}
